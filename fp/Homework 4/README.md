Домашно 4
===========

## ВАЖНО СЪОБЩЕНИЕ ##

От следващия час нататък, упражненията от 309к (2ра група) се местят в 122к и остават по същото време.
Ако някой днес е останал да чака пред 309к и не съм успял да му кажам, извинявам се :(

Тестовете към домашно 3 и 4 ще бъдат качени в началото на следващата седмица.
Проверяването на съответните домашни ще стане също тогава :)

##Задачи##

Решенията на задачите се предават по e-mail на адрес:

> radorado@hackfmi.com

Решението на всяка задача трябва да бъде под формата на файл с окончание *.scm* или *.rkt*, който да съдържа дефиницията на функцията (със точната сигнатура дефинирана в условието на задачата) и евентуално други помощни дефиниции, необходими за реализацията. Файловете се изпращат като attachment-и в mail-a. Освен решения на задачите самият mail трябва да съдържа име и факултен номер. Успех!

### Задача 1 ###

Напишете функция ```list-to-number```, която приема един аргумент - списък от цели числа и връща числото, което се получава, когато разгледаме всеки един елемент от списъцка като цифра.

Например, ако имаме списъкът ```(1 2 3 4 5)```, ```list-to-number``` функцията трябва да върне числото 12345

#### Сигнатура ####

```scheme
(define (list-to-number l) ... )
```
#### Примери ####

```scheme
(list-to-number (list 1 2 3)) ; 123
(list-to-number (list 1 0 2 0 3 0)) ; 102030
(list-to-number (list 0 0 0 0 0)) ; 0
(list-to-number (list 0 0 0 1 2 3)) ; 123
(list-to-number (list 0 8 4 3 2)) ; 8432
```

### Задача 2 ###

Напишете функция ```list-compose```, която приема за аргумент, списък от едноаргументни функции и връща функция, която представлява композицията на всички функции от списъка.
Например, ако имаме списъкът ```(f1 f2 f3 f4 f5)```, след изпълнението на ```list-compose``` ще имаме следната функция : ``` (h x) = (f1 (f2 (f3 (f3 (f5 x)))))```

#### Сигнатура ####

```scheme
(define (list-compose l) ... )
```

#### Примери ####

```scheme 
( (list-compose (list 
                    (lambda (x) (+ x 1)) 
                    (lambda (x) (* x 2)))) 
2) ; 5

( (list-compose (list 
                    (lambda (x) x))) 
2) ; 2

( (list-compose (list 
                 (lambda (x) (sqrt x))
                 (lambda (x) (expt x 2)))) 
4) ; 4
```

### Задача 3 ###

Напишете функция ```set-intersect```, която приема за аргумент два списъка ```l1``` и ```l2```, същоящи се от цели числа, и връща като резултат списък, представляващ сечението на списъците ```l1``` и ```l2```, разгледани като множества.

Резултатния списък трябва да бъде от уникални елементи и сортиран във възходящ ред.

**Тъй като не сме гледали никакви сортирания на Scheme**, може да ползвате [този материал и код](http://cs.gmu.edu/~white/CS363/Scheme/SchemeSamples.html) за помощ.

#### Сигнатура ####

```scheme
(define (set-intersect l1 l2) ... )
```

#### Примери ####
```scheme
(set-intersect (list 1 2 3) (list 4 5 6 1)) ; (1)
(set-intersect (list 5 6 7) (list 5 6 8)) ; (5 6)
(set-intersect (list 1 2 3) (list 4 5 6)) ; ()
(set-intersect (list 1 2 3 3 4 5 1 2 6 7) (list 7 7 7 7 3 3 2 2)) ; (2 3 7)
```
